{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"About Pajama","text":""},{"location":"about/#whats-pajama","title":"What's Pajama?","text":"<p>Pajama is a build system which enables software developers to build software quickly and easily. It lets them leverage skills and knowledge they already have, instead of forcing them to learn something new.</p> <p>Software developers already know how to build code. A C++ developer, for example, knows how to use a compiler to turn a source code file into an object file, and how to then use a linker to combine object files into a library or executable. They've known this since their very first days working with a compiled language. However, as software projects grow, it quickly becomes necessary to automate these manual steps. Otherwise the build process becomes time consuming and error prone.</p>"},{"location":"about/#enter-the-build-system","title":"Enter the build system.","text":"<p>A build system ensures these steps are done correctly every time, and only as required. But at this point, every build system forces the software developer to learn a new paradigm and syntax to describe how to create the executable. Every build system, that is, except Pajama.</p>"},{"location":"about/#pajama-is-different","title":"Pajama is different.","text":"<p>Pajama lets software developers work with the build system in ways they've understood since they were beginners.</p> <p>Pajama lets software developers describe the steps of a build sequentially. It allows them to use the output artifacts from one build step as input artifacts to the next build step. Pajama infers dependencies between artifacts based on how the build is described. And the build is described using simple Python -- a language most software developers already know.</p> <p>Build problems can easily eat up days of a software developer's time. They are often caused by a build system which is difficult to learn and therefore poorly understood.</p>"},{"location":"about/#win-win-win","title":"Win-win-win.","text":"<p>Pajama improves your software development process in three important ways:</p> <ol> <li>Save money by reducing developer time spent wrestling with the build system.</li> <li>Developers instead spend their time writing software to make your customers happy.</li> <li>Your developers are happier because they spend more time doing what they love to do -- writing code.</li> </ol>"},{"location":"about/#ready-to-learn-more","title":"Ready to learn more?","text":"<p>Try the tutorial to see Pajama in action.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p>TODO: Document pajama CLI, ideally by deriving the documentation from the CLI help output.</p>"},{"location":"cli/#build","title":"build","text":""},{"location":"cli/#build-dir","title":"build-dir","text":"<p>If unspecified, a directory named <code>build</code> will be created under the project directory. If specified (relative or absolute), the directory must exist. If absolute, a directory named after the project will be created under it.</p>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#abstract-tool","title":"abstract tool","text":"<p>Defines a set of functions to be implemented by a concrete tool. For example, the <code>cpp.compiler</code> abstract tool defines a set of functions which would be implemented by concrete tools <code>clang.cpp.compiler</code> and <code>gcc.cpp.compiler</code>.</p>"},{"location":"glossary/#action","title":"action","text":"<p>A build action takes one or more input artifacts and produces one or more output artifacts.</p>"},{"location":"glossary/#artifact","title":"artifact","text":"<p>Represents an entity like a file, directory, string, or other object used in the build process.</p>"},{"location":"glossary/#build-configuration","title":"build configuration","text":""},{"location":"glossary/#build-file","title":"build file","text":""},{"location":"glossary/#build-hierarchy","title":"build hierarchy","text":""},{"location":"glossary/#collection","title":"collection","text":"<p>A set of Python files containing functions and classes implementing one or more toolsets.</p>"},{"location":"glossary/#concrete-tool","title":"concrete tool","text":""},{"location":"glossary/#discovery","title":"discovery","text":"<p>The process of searching for a concrete tool on the user's system. This process is specific to the tool, and involves looking in the places the tool is commonly installed.</p>"},{"location":"glossary/#full-build","title":"full build","text":"<p>A full build is a build which performs all actions in order to produce all output artifacts.</p>"},{"location":"glossary/#implicit-dependency","title":"implicit dependency","text":"<p>An artifact which is not explicitly specified as an input artifact to a build action, but is implicitly used by the action. For example, a header file included by a source file used in a build action is an implicit dependency of that build build action.</p>"},{"location":"glossary/#incremental-build","title":"incremental build","text":"<p>An incremental build is a build which only performs actions whose input artifacts have changed, or whose output artifacts have been modified or deleted since the previous build.</p>"},{"location":"glossary/#input-artifact","title":"input artifact","text":"<p>An artifact which is used as input to a build action. For example, a source file is an input artifact to a build action which creates an object file.</p>"},{"location":"glossary/#inventory","title":"inventory","text":"<p>All the collections -- and hence all the toolsets and tools -- available to the build process.</p>"},{"location":"glossary/#named-artifact","title":"named artifact","text":"<p>An artifact which is assigned a name, so it can be referenced by that name elsewhere in the build.</p>"},{"location":"glossary/#output-artifact","title":"output artifact","text":"<p>An artifact which is created as a result of a build action. For example, an object file is an output artifact of a build action which compiles a source file.</p>"},{"location":"glossary/#relevant-settings","title":"relevant settings","text":""},{"location":"glossary/#setting","title":"setting","text":""},{"location":"glossary/#settings","title":"settings","text":""},{"location":"glossary/#target","title":"target","text":""},{"location":"glossary/#tool","title":"tool","text":""},{"location":"glossary/#toolset","title":"toolset","text":""},{"location":"snippets/","title":"Snippets","text":"<p>Tip</p> <p>Tip content</p> <p>Note</p> <p>Note content</p> Expandable ### Header 1. item 2. item  <p>https://squidfunk.github.io/mkdocs-material/reference/code-blocks/</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial walks you through the process of building a simple C++ project using Pajama. The project introduces several key Pajama features.</p>"},{"location":"tutorial/#download-and-install-pajama","title":"Download and Install Pajama","text":"<p>Note</p> <p>The version number shown here will change as new versions of Pajama are released. If you are reading this to reinstall Pajama, first refresh this page.</p> <pre><code>curl -LO https://joshcameron.github.io/pajama-docs/pajama-0.1.20250629030535-py3-none-any.whl\npython3 -m pip install pajama-0.1.20250629030535-py3-none-any.whl\n</code></pre> <p>The Pajama Python package contains a command line tool called <code>pajama</code> which is used to build projects. You can choose to install Pajama in your system Python as shown above, or in a virtual environment. If you choose to install Pajama in a virtual environment, you will need to activate the virtual environment before running the <code>pajama</code> command.</p>"},{"location":"tutorial/#clone-the-tutorial-code","title":"Clone the tutorial code","text":"<p>An example project is available on GitHub. Clone it to your local machine and follow along with the documentation below to learn how to use Pajama.</p> <pre><code>git clone git@github.com:joshcameron/pajama-tutorial.git\ncd pajama-tutorial\n</code></pre>"},{"location":"tutorial/#understand-the-project","title":"Understand the project","text":"<p>In pajama-tutorial, you will find a simple C++ project containing the following files and directories:</p> pajama-tutorial directory tree<pre><code>pajama-tutorial\n\u251c\u2500\u2500 .pajama\n\u251c\u2500\u2500 .pajama-project\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 config.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 .pajama\n    \u251c\u2500\u2500 a.cpp\n    \u251c\u2500\u2500 a.h\n    \u251c\u2500\u2500 b.cpp\n    \u251c\u2500\u2500 b.h\n    \u251c\u2500\u2500 c.cpp\n    \u2514\u2500\u2500 main.cpp\n</code></pre>"},{"location":"tutorial/#a-pajama-project-the-pajama-project-directory","title":"A Pajama project / The .pajama-project directory","text":"<p>The <code>.pajama-project</code> directory identifies the parent directory as the \"project directory\" -- the root directory of a Pajama project.</p> <p>When you use the <code>pajama</code> command at the prompt, the first thing it does is attempt to determine what Pajama project it is working with. It looks in the current directory and upwards through the parent directory hierarchy for a <code>.pajama-project</code> subdirectory.</p> <p>The <code>.pajama-project</code> directory initially contains a <code>config.toml</code> file, which specifies configuration options for the project. As you work with Pajama, other files may be created in this directory.</p>"},{"location":"tutorial/#pajama-files","title":".pajama files","text":"<p>Your project directory and the <code>src</code> directory below it both contain <code>.pajama</code> files. These files describe how to build the project. Each file describes how to build the contents of its directory.</p> <p><code>.pajama</code> files are Python files. If you already know Python, you are well on your way to writing Pajama code.</p> <p>Let's take a look at the <code>.pajama</code> file in the <code>src</code> directory. It looks like this:</p> src/.pajama<pre><code>from pajama import cpp, libtool, settings\n\ncpp.select_compiler('clang.cpp.compiler')\n\ncurrent_src_dir = settings.get('build.current_src_dir')\nsettings.set('clang.cpp.flags', f'-I{current_src_dir}')\ncurrent_build_dir = settings.get('build.current_build_dir')\nsettings.set('clang.cpp.flags', f'-L{current_build_dir}')\n\na_object = cpp.compile_to_object('a.cpp')\nb_object = cpp.compile_to_object('b.cpp', 'b.o')\n\n# Set to true if you want to link with a static library instead of a dynamic library.\nwant_static_lib = True\n\nstatic_lib = None\ndynamic_lib = None\n\nif want_static_lib:\n\n    static_lib = libtool.create_library([a_object, b_object], 'ab', dynamic=False)\n\nelse:\n\n    dynamic_lib = libtool.create_library([a_object, b_object], 'ab')\n\n# Compile main.cpp and link with the library.\nexecutable = cpp.compile_to_executable(\n    'main.cpp',\n    static_lib=static_lib,\n    dynamic_lib=dynamic_lib)\n</code></pre> <p>Just like a standard Python file, we begin by importing modules we need in the code below.</p> <p>The <code>cpp</code> module provides functions for selecting a compiler and compiling C++ code. In this file, we use <code>cpp.select_compiler()</code> to select the <code>clang.cpp.compiler</code> tool. Subsequent calls to the <code>cpp.compile_to_object()</code> and <code>cpp.compile_to_executable()</code> functions use the <code>clang</code> compiler to compile the code.</p> <p>The <code>cpp</code> module is an example of what is called an abstract tool. When a function from the <code>cpp</code> module is invoked in a <code>.pajama</code> file, the action taken by the function will be performed using the currently selected concrete tool. There are many possible C++ compilers, of course, and in this example we select <code>clang.cpp.compiler</code> to perform our C++ compiles. Using the functions provided by a generic tool like <code>cpp</code> allows us to write code which is agnostic of the actual compiler being used. This makes it easy to change the compiler used for all or part of the project.</p> <p>The <code>settings</code> module provides functions for setting and getting build settings. Settings are used implicitly by the tools they are associated with. For example, the <code>clang.cpp.flags</code> setting is used by <code>clang.cpp.compiler</code> to set the flags used when compiling C++ code. Settings can also be used explicitly, as shown in this code where we use the <code>build.current_src_dir</code> and <code>build.current_build_dir</code> settings to set the include and library paths for the compiler.</p> <p>The <code>libtool</code> module provides functions for creating static and dynamic libraries. In this file, we use <code>libtool.create_library()</code> to create a static or dynamic library from the object files. The decision to create a static or dynamic library is controlled by an ordinary Python if statement and an ordinary Python variable.</p> <p>The return values of <code>settings.get()</code>, <code>cpp.compile_to_object()</code>, <code>libtool.create_library()</code> and <code>cpp.compile_to_executable()</code> are all build artifacts. Artifacts represent entities like files, directories, and strings used in the build process. Some artifacts are created by actions of the build process, while others -- such as source files -- exist prior to invoking the build.</p>"},{"location":"tutorial/#initial-build-full-build-clean-build","title":"Initial build / full build / clean build","text":"<p>To build pajama-tutorial for the first time:</p> <pre><code>cd pajama-tutorial\npajama build --clean\n</code></pre> <p>The <code>pajama build --clean</code> command deletes all existing output artifacts (if any) and performs a full build -- all actions necessary to build all output artifacts described by the build's <code>.pajama</code> files.</p> <p>If ever you want to ensure every output artifact of your project gets rebuilt, you can do so with <code>pajama build --clean</code>.</p>"},{"location":"tutorial/#incremental-build","title":"Incremental build","text":"<p>During your day to day work, you will typically perform an incremental build. This means using Pajama to build only the output artifacts which need to be built, based on the current state of the project. For example, if you modify <code>main.cpp</code>, you can run:</p> <pre><code>pajama build\n</code></pre> <p>Pajama will then only rebuild the output artifacts which depend on <code>main.cpp</code>, such as <code>a.out</code>, the executable created from <code>main.cpp</code>. It will not rebuild the static or dynamic libraries, since neither <code>a.cpp</code> nor <code>b.cpp</code> have changed.</p> <p>Pajama infers the dependencies of the build based on how build artifacts are created from other artifacts. For example, <code>main.cpp</code> is an input artifact to a build action which creates output artifact <code>a.out</code>. Pajama has also cached information about the actions performed in the previous build. It knows if <code>main.cpp</code> has not been modified, and the settings relevant to the action which creates <code>a.out</code> have not changed, then <code>a.out</code> does not need to be created again. In an incremental build, Pajama does only what needs to be done.</p> <p>Note</p> <p>When building a project for the first time, a <code>pajama build</code> command is equivalent to a <code>pajama build --clean</code> command, because none of the output artifacts exist yet.</p>"},{"location":"tutorial/#features","title":"Features","text":"<ul> <li>Library to share code among multiple applications</li> <li>.cpp to .o</li> <li>.o to .so (dynamic library)</li> <li>.o to .a (static library)</li> <li>executable</li> <li>full build, then incremental: note that incremental is fast</li> <li>add .cpp to the build: note that other .cpps don't need to be rebuilt.</li> </ul>"},{"location":"tutorial/#current-limitations","title":"Current limitations","text":"<p>Pajama is currently in a very early alpha state.</p> <ul> <li>It is only tested on macOS</li> <li>The only supported toolset is clang</li> <li>Esoteric clang flags might not work. Let me know if something you need is not   supported.</li> <li>Parallelism is not yet supported.</li> </ul> <p>The focus is on demonstrating the key differentiating feature of Pajama: it allows you to work with the build system in a more intuitive way, because it's so similar to how you would manually build code from the command line.</p>"},{"location":"event/build/","title":"Build","text":"<p>Build event</p>"},{"location":"event/init/","title":"Init","text":"<p>Init event</p>"},{"location":"user-docs/clang/","title":"clang","text":"<p>This module declares no user facing functions. Invoke the clang compiler by using <code>pajama.cpp.select_compiler('clang.cpp.compiler')</code> to select the clang compiler and using <code>pajama.cpp.compile()</code> to compile.</p>"},{"location":"user-docs/cpp/","title":"cpp","text":""},{"location":"user-docs/cpp/#collection.cpp.compile_to_executable","title":"compile_to_executable","text":"<pre><code>compile_to_executable(src_file, dst_file_name=None, static_lib=None, dynamic_lib=None)\n</code></pre> <p>Compile a C++ source file to an executable file.</p> <p>Parameters:</p> Name Type Description Default <code>src_file</code> <code>str | FileArtifact</code> <p>The source file to compile.</p> required <code>dst_file_name</code> <code>str | None</code> <p>The name of the execuable file to create. If None, the execuable file                    will be created in the current build directory with the default name given to an                        executable by the current compiler.</p> <code>None</code>"},{"location":"user-docs/cpp/#collection.cpp.compile_to_object","title":"compile_to_object","text":"<pre><code>compile_to_object(src_file, dst_file_name=None)\n</code></pre> <p>Compile a C++ source file to an object file.</p> <p>Parameters:</p> Name Type Description Default <code>src_file</code> <code>str | FileArtifact</code> <p>The source file to compile.</p> required <code>dst_file_name</code> <code>str | None</code> <p>The name of the object file to create. If None, the object file                  will be created in the current build directory with a name based on the source file                     name, with the appropriate extension for an object file on this operating system.</p> <code>None</code>"},{"location":"user-docs/cpp/#collection.cpp.link_library","title":"link_library","text":"<pre><code>link_library(object_files, dst_file_name)\n</code></pre> <p>Link object files into a static or dynamic library.</p> <p>Parameters:</p> Name Type Description Default <code>object_files</code> <code>list</code> <p>The object files to link.</p> required <code>dst_file_name</code> <code>str</code> <p>The name of the library to create.</p> required"},{"location":"user-docs/cpp/#collection.cpp.select_abstract_tool","title":"select_abstract_tool","text":"<pre><code>select_abstract_tool(tool_id, setting_name, abstract_cls, min_version=None, max_version=None)\n</code></pre> <p>Request the use of the specified type of tool in the specified version range.</p> <p>Parameters:</p> Name Type Description Default <code>tool_id</code> <code>str</code> <p>The id of the compiler to use.</p> required <code>min_version</code> <code>str | None</code> <p>The minimum version of the compiler to use.</p> <code>None</code> <code>max_version</code> <code>str | None</code> <p>The maximum version of the compiler to use.</p> <code>None</code>"},{"location":"user-docs/cpp/#collection.cpp.select_compiler","title":"select_compiler","text":"<pre><code>select_compiler(tool_id, min_version=None, max_version=None)\n</code></pre> <p>Request the use of the specified compiler in the specified version range.</p> <p>Parameters:</p> Name Type Description Default <code>tool_id</code> <code>str</code> <p>The id of the compiler to use.</p> required <code>min_version</code> <code>str | None</code> <p>The minimum version of the compiler to use.</p> <code>None</code> <code>max_version</code> <code>str | None</code> <p>The maximum version of the compiler to use.</p> <code>None</code>"},{"location":"user-docs/cpp/#collection.cpp.select_tool","title":"select_tool","text":"<pre><code>select_tool(tool_id, setting_name, expected_cls, min_version=None, max_version=None)\n</code></pre> <p>Request the use of the specified type of tool in the specified version range.</p> <p>Parameters:</p> Name Type Description Default <code>tool_id</code> <code>str</code> <p>The id of the compiler to use.</p> required <code>min_version</code> <code>str | None</code> <p>The minimum version of the compiler to use.</p> <code>None</code> <code>max_version</code> <code>str | None</code> <p>The maximum version of the compiler to use.</p> <code>None</code>"},{"location":"user-docs/filesystem/","title":"filesystem","text":"<p>Implements typical filesystem functionality, such as copying files and directories.</p>"},{"location":"user-docs/filesystem/#pajama.filesystem.copy_dir","title":"copy_dir","text":"<pre><code>copy_dir(src_dir, dst_dir)\n</code></pre> <p>Copy a directory.</p> <p>Recursively copy the specified directory to the specified destination directory.</p> <p>Parameters:</p> Name Type Description Default <code>src_dir</code> <code>DirectoryTreeArtifact | str</code> <p>The source directory. If <code>str</code>, <code>src_dir</code> can be an absolute path or a path  relative to setting <code>build.current_src_dir</code>.</p> required <code>dst_dir</code> <code>DirectoryArtifact | str</code> <p>The destination directory. If <code>str</code>, <code>dst_dir</code> must be a path relative to setting <code>build.current_build_dir</code>. </p> required <p>Example: <pre><code>&gt;&gt;&gt; some_string = 'hello'\n&gt;&gt;&gt; len(some_string)\n5\n</code></pre></p>"},{"location":"user-docs/filesystem/#pajama.filesystem.copy_file","title":"copy_file","text":"<pre><code>copy_file(src_file, dst_dir, new_file_name=None)\n</code></pre> <p>Copy a file.</p> <p>Copy the specified file to the specified directory. The copy can be given a new name.</p> <p>Parameters:</p> Name Type Description Default <code>src_file</code> <code>FileArtifact | str</code> <p>Source file path (absolute, or relative to setting <code>build.current_src_dir</code>).</p> required <code>dst_dir</code> <code>DirectoryArtifact | StringArtifact | str</code> <p>Destination directory path (absolute, or relative to setting <code>build.current_build_dir</code>).</p> required <code>new_file_name</code> <code>str | None</code> <p>(Optional) New name for the copied file.</p> <code>None</code>"},{"location":"user-docs/filesystem/#pajama.filesystem.make_directory","title":"make_directory","text":"<pre><code>make_directory(rel_path)\n</code></pre> <p>Make a directory, and any necessary non-existent parent directories.</p> <p>Parameters:</p> Name Type Description Default <code>rel_path</code> <code>str</code> <p>The path of the directory to be created, relative to the current build directory.</p> required"},{"location":"user-docs/libtool/","title":"libtool","text":""},{"location":"user-docs/libtool/#collection.libtool.create_library","title":"create_library","text":"<pre><code>create_library(object_files, library_base_name, dynamic=True)\n</code></pre> <p>Link object files into a static or dynamic library.</p> <p>Args:</p> <pre><code>    object_files:                   The object files to link.\n\n    library_base_name:                      The base name of the library. The base name will be prefixed with lib and suffixed                      with .a for a static library, or .dylib for a dynamic library.\n</code></pre>"},{"location":"user-docs/libtool/#collection.libtool.select","title":"select","text":"<pre><code>select(min_version=None, max_version=None)\n</code></pre> <p>Request the use of libtool in the specified version range.</p> <p>Parameters:</p> Name Type Description Default <code>min_version</code> <code>str | None</code> <p>The minimum version of libtool to use.</p> <code>None</code> <code>max_version</code> <code>str | None</code> <p>The maximum version of libtool to use.</p> <code>None</code>"},{"location":"user-docs/log/","title":"log","text":""},{"location":"user-docs/log/#pajama.log.critical","title":"critical","text":"<pre><code>critical(message, tag='untagged', stacklevel=3)\n</code></pre> <p>Log a critical error message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>tag</code> <code>str</code> <p>A string that can be used to filter log messages.</p> <code>'untagged'</code> <code>stacklevel</code> <code>int</code> <p>The number of stack frames to skip when determining the                     location of the log message. The default value of 3 is usually                  appropriate.</p> <code>3</code>"},{"location":"user-docs/log/#pajama.log.debug","title":"debug","text":"<pre><code>debug(message, tag='untagged', stacklevel=3)\n</code></pre> <p>Log a debug message. Debug messages are prefaced with the file and line number where this function was called.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>tag</code> <code>str</code> <p>A string that can be used to filter log messages.</p> <code>'untagged'</code> <code>stacklevel</code> <code>int</code> <p>The number of stack frames to skip when determining the                     location of the log message. The default value of 3 is usually                  appropriate.</p> <code>3</code> <p>Example: <pre><code>some_string = 'hello'\nlog.debug(f'some_string is {some_string}')\n# DEBUG filename.py:123 : [untagged] some_string is hello\n</code></pre></p>"},{"location":"user-docs/log/#pajama.log.debug_stack","title":"debug_stack","text":"<pre><code>debug_stack(tag='untagged', stacklevel=3)\n</code></pre> <p>Log the current stack trace.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A string that can be used to filter log messages.</p> <code>'untagged'</code> <code>stacklevel</code> <code>int</code> <p>The number of stack frames to skip when determining the                     location of the log message. The default value of 3 is usually                  appropriate.</p> <code>3</code>"},{"location":"user-docs/log/#pajama.log.error","title":"error","text":"<pre><code>error(message, tag='untagged', stacklevel=3)\n</code></pre> <p>Log an error message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>tag</code> <code>str</code> <p>A string that can be used to filter log messages.</p> <code>'untagged'</code> <code>stacklevel</code> <code>int</code> <p>The number of stack frames to skip when determining the                     location of the log message. The default value of 3 is usually                  appropriate.</p> <code>3</code>"},{"location":"user-docs/log/#pajama.log.info","title":"info","text":"<pre><code>info(message, tag='untagged', stacklevel=3)\n</code></pre> <p>Log an informational message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>tag</code> <code>str</code> <p>A string that can be used to filter log messages.</p> <code>'untagged'</code> <code>stacklevel</code> <code>int</code> <p>The number of stack frames to skip when determining the                     location of the log message. The default value of 3 is usually                  appropriate.</p> <code>3</code>"},{"location":"user-docs/log/#pajama.log.verbose_debug","title":"verbose_debug","text":"<pre><code>verbose_debug(message, tag='untagged', stacklevel=3)\n</code></pre> <p>Log a verbose debug message. A verbose debug message provides additional detail, and    is only logged if the verbose flag is set.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>tag</code> <code>str</code> <p>A string that can be used to filter log messages.</p> <code>'untagged'</code> <code>stacklevel</code> <code>int</code> <p>The number of stack frames to skip when determining the                     location of the log message. The default value of 3 is usually                  appropriate.</p> <code>3</code>"},{"location":"user-docs/log/#pajama.log.warning","title":"warning","text":"<pre><code>warning(message, tag='untagged', stacklevel=3)\n</code></pre> <p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>tag</code> <code>str</code> <p>A string that can be used to filter log messages.</p> <code>'untagged'</code> <code>stacklevel</code> <code>int</code> <p>The number of stack frames to skip when determining the                     location of the log message. The default value of 3 is usually                  appropriate.</p> <code>3</code>"},{"location":"user-docs/settings/","title":"settings","text":"<p>Settings store values to be used later in the build. </p> <p>Setting names and types are declared and registered by Pajama toolsets or by Pajama itself.  There are two setting types: single-value settings, and dictionary settings. Single-value settings  consist of a setting name and a value. Dictionary settings consist of a setting name and a  dictionary of key-value pairs.</p>"},{"location":"user-docs/settings/#pajama.settings.contains","title":"contains","text":"<pre><code>contains(setting_name)\n</code></pre> <p>Check if a setting with the specified name is in the current settings.</p> <p>Parameters:</p> Name Type Description Default <code>setting_name</code> <code>str</code> <p>The name of the setting to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a setting with the specified name is in the current settings.</p>"},{"location":"user-docs/settings/#pajama.settings.get","title":"get","text":"<pre><code>get(setting_name)\n</code></pre> <p>Get the value of the named setting.</p> <p>Parameters:</p> Name Type Description Default <code>setting_name</code> <code>str</code> <p>The name of the setting to get. Use of an unregistered setting name will  raise an exception.</p> required <p>Returns:</p> Type Description <code>Artifact</code> <p>The value of the setting.</p> <p>Raises:</p> Type Description <code>UseOfUnregisteredSettingName</code> <p>If the setting name is not registered.</p>"},{"location":"user-docs/settings/#pajama.settings.set","title":"set","text":"<pre><code>set(setting_name, *args)\n</code></pre> <p>Set the value of the named setting.</p> <p>Parameters:</p> Name Type Description Default <code>setting_name</code> <code>str</code> <p>The name of the setting to set.</p> required <code>args</code> <p>The value to set the setting to. For single-value settings, <code>args</code> is  <code>str | Artifact</code>. <code>str</code> values will automatically be converted to <code>StringArtifact</code>. For dictionary settings, <code>args</code> is typically <code>str</code> key and <code>str | Artifact</code> value.  Again, <code>str</code> values will automatically be converted to <code>StringArtifact</code>. Callers who need to set the entire dictionary at once can pass a <code>DictOfArtifacts</code>. </p> <code>()</code> <p>Raises:</p> Type Description <code>UseOfUnregisteredSettingName</code> <p>If the setting name is not registered.</p> <p>Example: <pre><code>from pajama import settings, artifact\n\nfile_artifact = artifact.FileArtifact('foo.c')\n\n# Set a single-value setting to an artifact value.\nsettings.set('some_toolset.some_file', file_artifact)\n\n# Set a single-value setting to a string value.\nsettings.set('some_toolset.some_string', 'hello')\n\n# Set dictionary settings to key-value pairs.\nsettings.set('some_toolset.some_dict', 'key_name', file_artifact)\nsettings.set('some_toolset.some_dict', 'another_key_name', 'a different value')\n</code></pre></p>"}]}